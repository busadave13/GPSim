@page "/"
@page "/simulator"
@using GPSim.Client.Services
@using GPSim.Shared.Models
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="simulator-container" style="position: relative; width: 100%; height: 100vh;">
    <!-- Map Container -->
    <div id="map" class="map-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>

    <!-- Control Panel -->
    <div class="control-panel">
        <h5 class="mb-3">üöó GPS Simulator</h5>

        <!-- Status Display -->
        <div class="mb-3">
            <div class="section-title">Status</div>
            <div class="d-flex align-items-center mb-2">
                <span class="status-indicator @GetStatusClass()"></span>
                <span class="ms-2">@GetStatusText()</span>
            </div>
            
            <!-- Pause/Resume Buttons -->
            @if (SimulationMode != Mode.Initializing)
            {
                <div class="mt-2">
                    @if (IsPaused)
                    {
                        <button class="btn btn-success btn-sm w-100" @onclick="ResumeSimulation">
                            ‚ñ∂Ô∏è Resume
                        </button>
                    }
                    else
                    {
                        <button class="btn btn-warning btn-sm w-100" @onclick="PauseSimulation">
                            ‚è∏Ô∏è Pause
                        </button>
                    }
                </div>
            }
            
            @if (CurrentPosition != null)
            {
                <div class="coordinate-display" style="font-size: 0.8rem;">
                    <div><strong>Lat:</strong> @CurrentPosition.Latitude.ToString("F6")</div>
                    <div><strong>Lng:</strong> @CurrentPosition.Longitude.ToString("F6")</div>
                    @if (SimulationMode == Mode.Moving && SimulationProgress > 0)
                    {
                        <div><strong>Progress:</strong> @((SimulationProgress * 100).ToString("F1"))%</div>
                        @if (CurrentSpeedLimit.HasValue)
                        {
                            <div><strong>Speed Limit:</strong> @CurrentSpeedLimit MPH</div>
                        }
                        else
                        {
                            <div><strong>Speed:</strong> @Settings.SpeedMph.ToString("F0") MPH <span
                                    class="text-warning">(fallback)</span></div>
                        }
                    }
                    <div><strong>Zoom:</strong> @CurrentZoomLevel.ToString("F1")</div>
                </div>
            }
        </div>

        <!-- Instructions -->
        <div class="mb-3">
            <div class="section-title">Instructions</div>
            <small class="text-muted">
                @if (SimulationMode == Mode.Initializing)
                {
                    <span>üìç Detecting your location...</span>
                }
                else if (SimulationMode == Mode.Stationary)
                {
                    <span>üëÜ Click anywhere on the map to set a destination</span>
                }
                else if (SimulationMode == Mode.Moving)
                {
                    <span>üöó Moving to destination. Click to change destination.</span>
                }
            </small>
        </div>

        <!-- Simulation Settings -->
        <div class="mb-3">
            <div class="section-title">Settings</div>

            <div class="mb-2">
                <label class="form-label">Update Interval: @Settings.IntervalMs ms</label>
                <input type="range" class="form-range" @bind="Settings.IntervalMs" @bind:event="oninput" 
                    min="50" max="500" step="10" />
                <small class="text-muted">Controls animation smoothness</small>
            </div>

            <div class="mb-2">
                <label class="form-label">Webhook Interval (ms)</label>
                <input type="number" class="form-control form-control-sm" @bind="Settings.WebhookIntervalMs" 
                    min="100" max="60000" step="100" />
                <small class="text-muted">How often GPS data is sent to webhook</small>
            </div>

            <div class="mb-2">
                <label class="form-label">Fallback Speed (MPH)</label>
                <input type="number" class="form-control form-control-sm" @bind="Settings.SpeedMph" min="1" max="200"
                    step="1" />
                <small class="text-muted">Used when road speed limit is unavailable</small>
            </div>

            <div class="mb-2">
                <label class="form-label">Webhook URL</label>
                <input type="text" class="form-control form-control-sm" @bind="Settings.WebhookUrl"
                    placeholder="Optional override" />
            </div>

            <div class="mb-2">
                <label class="form-label">Webhook Headers</label>
                <input type="text" class="form-control form-control-sm" @bind="Settings.WebhookHeaders"
                    placeholder="Header1:Value1;Header2:Value2" />
            </div>
        </div>

        <!-- Destination Info -->
        @if (EndPoint != null)
        {
            <div class="mb-3">
                <div class="section-title">Destination</div>
                <div class="coordinate-display" style="font-size: 0.8rem;">
                    <div><strong>Lat:</strong> @EndPoint.Latitude.ToString("F6")</div>
                    <div><strong>Lng:</strong> @EndPoint.Longitude.ToString("F6")</div>
                </div>
            </div>
        }
    </div>
</div>

@code {
    private MapboxInteropService? _mapService;
    private string? _accessToken;
    private double _circleRadiusMiles = 0.1;
    private CancellationTokenSource? _simulationCts;
    private Task? _simulationTask;

    // Current position state
    private Coordinate? CurrentPosition;
    private Coordinate? EndPoint;
    private RouteGeometry? CurrentRoute;

    // Simulation mode
    private Mode SimulationMode = Mode.Initializing;

    // Simulation settings
    private SimulationSettings Settings = new()
    {
        IntervalMs = 100,
        WebhookIntervalMs = 1000,
        SpeedMph = 25.0,
        WebhookUrl = "",
        WebhookHeaders = ""
    };

    // Simulation tracking
    private double SimulationProgress = 0;
    private DateTime RouteStartTime;
    private double DistanceTraveledMeters = 0;
    private DateTime LastTickTime;
    private DateTime LastWebhookSendTime = DateTime.MinValue;

    // Speed limit tracking
    private int? CurrentSpeedLimit = null;
    private int CurrentSegmentIndex = 0;

    // Map state tracking
    private double CurrentZoomLevel = 12.0;

    // Pause state tracking - using a field that's checked each tick
    private volatile bool IsPaused = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeMapAsync();
        }
    }

    private async Task InitializeMapAsync()
    {
        try
        {
            // Get Mapbox configuration from server
            var config = await Http.GetFromJsonAsync<MapboxConfig>("api/configuration/mapbox");
            if (config != null)
            {
                _accessToken = config.AccessToken;
                _circleRadiusMiles = config.CircleRadiusMiles;
            }

            // Get webhook configuration from server (resolved from env vars or appsettings)
            var webhookConfig = await Http.GetFromJsonAsync<WebhookConfig>("api/configuration/webhook");
            if (webhookConfig != null)
            {
                Settings.WebhookUrl = webhookConfig.DefaultUrl ?? "";
                Settings.WebhookHeaders = webhookConfig.DefaultHeaders ?? "";
                Settings.WebhookIntervalMs = webhookConfig.IntervalMs;
            }

            _mapService = new MapboxInteropService(JSRuntime);

            // Subscribe to events before initializing
            _mapService.OnMapClicked += OnMapClickedAsync;
            _mapService.OnInitialLocationReceived += OnInitialLocationAsync;
            _mapService.OnZoomLevelChanged += OnZoomLevelChangedAsync;

            await _mapService.InitializeAsync("map", _accessToken ?? "", null, 12, _circleRadiusMiles);

            // Enable click capture (this also sets the dotNetRef for callbacks)
            await _mapService.EnableClickCaptureAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
        }
    }

    private async Task OnInitialLocationAsync(double longitude, double latitude)
    {
        // Set initial position
        CurrentPosition = new Coordinate(latitude, longitude);
        SimulationMode = Mode.Stationary;

        // Start the continuous simulation loop
        StartSimulationLoop();

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnZoomLevelChangedAsync(double zoomLevel)
    {
        CurrentZoomLevel = zoomLevel;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnMapClickedAsync(double longitude, double latitude)
    {
        if (_mapService == null || CurrentPosition == null) return;

        try
        {
            // Get current marker position (in case we're moving)
            var markerPos = await _mapService.GetMarkerPositionAsync();
            if (markerPos != null)
            {
                CurrentPosition = new Coordinate(markerPos.Lat, markerPos.Lng);
            }

            // Set new destination
            EndPoint = new Coordinate(latitude, longitude);

            // Remove radius circle if shown
            await _mapService.RemoveRadiusCircleAsync();

            // Clear old route and waypoints
            await _mapService.ClearRouteAsync();
            await _mapService.ClearWaypointsAsync();

            // Place end marker
            await _mapService.SetWaypointAsync(longitude, latitude, "end");

            // Get directions from current position to destination
            var route = await _mapService.GetDirectionsAsync(CurrentPosition!, EndPoint);

            if (route != null)
            {
                CurrentRoute = route;
                await _mapService.DrawRouteAsync(route);

                // Start moving - reset all tracking variables
                SimulationMode = Mode.Moving;
                SimulationProgress = 0;
                DistanceTraveledMeters = 0;
                CurrentSegmentIndex = 0;
                CurrentSpeedLimit = null;
                RouteStartTime = DateTime.UtcNow;
                LastTickTime = DateTime.UtcNow;

                // Log speed limit availability
                Console.WriteLine($"Route has {route.SpeedLimits.Count} speed limit segments");
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling map click: {ex.Message}");
        }
    }

    private void StartSimulationLoop()
    {
        _simulationCts = new CancellationTokenSource();
        _simulationTask = RunSimulationLoopAsync(_simulationCts.Token);
    }

    private async Task RunSimulationLoopAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(Settings.IntervalMs));

            while (await timer.WaitForNextTickAsync(cancellationToken))
            {
                await SimulationTickAsync();
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when simulation is stopped
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Simulation loop error: {ex.Message}");
        }
    }

    private async Task SimulationTickAsync()
    {
        if (_mapService == null || CurrentPosition == null) return;

        // Skip all processing if paused - check at the beginning
        var isPausedNow = IsPaused;
        if (isPausedNow)
        {
            Console.WriteLine($"[DEBUG] Tick skipped - IsPaused={isPausedNow}");
            await InvokeAsync(StateHasChanged);
            return;
        }
        
        Console.WriteLine($"[DEBUG] Tick processing - IsPaused={isPausedNow}, Mode={SimulationMode}");

        try
        {
            if (SimulationMode == Mode.Moving && CurrentRoute != null)
            {
                // Calculate time since last tick
                var now = DateTime.UtcNow;
                var tickDeltaSeconds = (now - LastTickTime).TotalSeconds;
                LastTickTime = now;

                // Get current speed (based on speed limit mode)
                var currentSpeedMph = GetCurrentSpeed();
                var speedMetersPerSecond = currentSpeedMph * 1609.344 / 3600.0;

                // Accumulate distance traveled
                DistanceTraveledMeters += speedMetersPerSecond * tickDeltaSeconds;

                // Calculate progress as fraction of total route distance
                var routeDistanceMeters = CurrentRoute.DistanceMeters;
                SimulationProgress = Math.Min(1.0, DistanceTraveledMeters / routeDistanceMeters);

                // Interpolate position
                var interpolated = await _mapService.InterpolatePositionAsync(CurrentRoute, SimulationProgress);

                if (interpolated != null && interpolated.Position.Length >= 2)
                {
                    var lng = interpolated.Position[0];
                    var lat = interpolated.Position[1];
                    CurrentPosition = new Coordinate(lat, lng);

                    // Update speed limit from current segment
                    CurrentSegmentIndex = interpolated.SegmentIndex;
                    if (CurrentRoute.SpeedLimits.Count > CurrentSegmentIndex)
                    {
                        var segmentSpeedLimit = CurrentRoute.SpeedLimits[CurrentSegmentIndex];
                        // Only set if the speed limit is valid (non-null, non-zero)
                        CurrentSpeedLimit = segmentSpeedLimit > 0 ? segmentSpeedLimit : null;
                    }
                    else
                    {
                        CurrentSpeedLimit = null;
                    }

                    // Animate marker
                    await _mapService.AnimateMarkerAsync(lng, lat, interpolated.Bearing, Settings.IntervalMs);

                    // Send GPS data with actual current speed (only if not paused)
                    if (!IsPaused)
                    {
                        _ = SendGpsDataAsync(lat, lng, interpolated.Bearing, currentSpeedMph);
                    }
                }

                // Check if we've reached the destination
                if (SimulationProgress >= 1.0)
                {
                    await OnReachedDestinationAsync();
                }
            }
            else if (SimulationMode == Mode.Stationary && !IsPaused)
            {
                // When stationary, just keep sending current position (only if not paused)
                _ = SendGpsDataAsync(CurrentPosition.Latitude, CurrentPosition.Longitude, 0, 0);
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Simulation tick error: {ex.Message}");
        }
    }

    private async Task OnReachedDestinationAsync()
    {
        if (_mapService == null || CurrentPosition == null) return;

        Console.WriteLine($"Reached destination at: {CurrentPosition.Latitude}, {CurrentPosition.Longitude}");

        // Transition to stationary mode
        SimulationMode = Mode.Stationary;

        // Clear route and end marker
        await _mapService.ClearRouteAsync();
        await _mapService.ClearWaypointsAsync();

        // Small delay to ensure Mapbox has finished removing layers
        await Task.Delay(100);

        // Draw radius circle at current position using configured radius
        Console.WriteLine($"Drawing radius circle at: {CurrentPosition.Longitude}, {CurrentPosition.Latitude}, radius: {_circleRadiusMiles} miles");
        await _mapService.DrawRadiusCircleAsync(CurrentPosition.Longitude, CurrentPosition.Latitude, _circleRadiusMiles);

        // Clear route data
        CurrentRoute = null;
        EndPoint = null;
        SimulationProgress = 0;
    }

    private async Task SendGpsDataAsync(double latitude, double longitude, double bearing, double speedMph = 0)
    {
        try
        {
            // Check if enough time has passed since last webhook send
            var now = DateTime.UtcNow;
            var timeSinceLastSend = (now - LastWebhookSendTime).TotalMilliseconds;
            if (timeSinceLastSend < Settings.WebhookIntervalMs)
            {
                // Not enough time has passed, skip this webhook send
                return;
            }
            
            // Update last send time
            LastWebhookSendTime = now;

            // Convert MPH to m/s
            var speedMetersPerSecond = speedMph * 1609.344 / 3600.0;

            var payload = new GpsPayload
            {
                Latitude = latitude,
                Longitude = longitude,
                Altitude = 0,
                Speed = speedMetersPerSecond,
                Bearing = bearing,
                Accuracy = 5.0,
                Timestamp = DateTime.UtcNow
            };

            var queryParams = new List<string>();

            if (!string.IsNullOrEmpty(Settings.WebhookUrl))
            {
                queryParams.Add($"webhookUrl={Uri.EscapeDataString(Settings.WebhookUrl)}");
            }

            if (!string.IsNullOrEmpty(Settings.WebhookHeaders))
            {
                queryParams.Add($"webhookHeaders={Uri.EscapeDataString(Settings.WebhookHeaders)}");
            }

            var url = queryParams.Count > 0
            ? $"api/webhook/broadcast?{string.Join("&", queryParams)}"
            : "api/webhook/broadcast";

            await Http.PostAsJsonAsync(url, payload);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending GPS data: {ex.Message}");
        }
    }

    private string GetStatusClass()
    {
        if (IsPaused) return "status-idle";
        
        return SimulationMode switch
        {
            Mode.Initializing => "status-idle",
            Mode.Stationary => "status-paused",
            Mode.Moving => "status-running",
            _ => "status-idle"
        };
    }

    private string GetStatusText()
    {
        if (IsPaused) return "‚è∏Ô∏è Paused";
        
        return SimulationMode switch
        {
            Mode.Initializing => "Initializing...",
            Mode.Stationary => "Stationary (sending updates)",
            Mode.Moving => "Moving to destination",
            _ => "Unknown"
        };
    }

    /// <summary>
    /// Pauses the simulation
    /// </summary>
    private void PauseSimulation()
    {
        Console.WriteLine("[DEBUG] PauseSimulation called");
        IsPaused = true;
        Console.WriteLine($"[DEBUG] IsPaused set to {IsPaused}");
        StateHasChanged();
    }

    /// <summary>
    /// Resumes the simulation
    /// </summary>
    private void ResumeSimulation()
    {
        IsPaused = false;
        // Reset LastTickTime to prevent large time jump when resuming
        LastTickTime = DateTime.UtcNow;
        StateHasChanged();
    }

    /// <summary>
    /// Gets the current speed - uses road speed limit if available, otherwise fallback speed
    /// </summary>
    private double GetCurrentSpeed()
    {
        // Use the road's speed limit if available
        if (CurrentSpeedLimit.HasValue)
        {
            return CurrentSpeedLimit.Value;
        }

        // Fallback to configured speed (default 30 MPH) when speed limit is unknown
        return Settings.SpeedMph;
    }

    public async ValueTask DisposeAsync()
    {
        _simulationCts?.Cancel();
        _simulationCts?.Dispose();

        if (_simulationTask != null)
        {
            try
            {
                await _simulationTask;
            }
            catch
            {
                // Ignore
            }
        }

        if (_mapService != null)
        {
            _mapService.OnMapClicked -= OnMapClickedAsync;
            _mapService.OnInitialLocationReceived -= OnInitialLocationAsync;
            _mapService.OnZoomLevelChanged -= OnZoomLevelChangedAsync;
            await _mapService.DisposeAsync();
        }
    }

    private record MapboxConfig(string AccessToken, double CircleRadiusMiles = 0.1);
    private record WebhookConfig(string DefaultUrl, string DefaultHeaders, int IntervalMs = 1000);

    private enum Mode
    {
        Initializing,
        Stationary,
        Moving
    }
}
