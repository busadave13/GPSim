@page "/"
@page "/simulator"
@using GPSim.Client.Services
@using GPSim.Shared.Models
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="simulator-container" style="position: relative; width: 100%; height: 100vh;">
    <!-- Map Container -->
    <div id="map" class="map-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <h5 class="mb-3">üöó GPS Simulator</h5>
        
        <!-- Status Display -->
        <div class="mb-3">
            <div class="section-title">Status</div>
            <div class="d-flex align-items-center mb-2">
                <span class="status-indicator @GetStatusClass()"></span>
                <span class="ms-2">@GetStatusText()</span>
            </div>
            @if (CurrentPosition != null)
            {
                <div class="coordinate-display" style="font-size: 0.8rem;">
                    <div><strong>Lat:</strong> @CurrentPosition.Latitude.ToString("F6")</div>
                    <div><strong>Lng:</strong> @CurrentPosition.Longitude.ToString("F6")</div>
                    @if (SimulationMode == Mode.Moving && SimulationProgress > 0)
                    {
                        <div><strong>Progress:</strong> @((SimulationProgress * 100).ToString("F1"))%</div>
                        @if (MatchSpeedLimits && CurrentSpeedLimit.HasValue)
                        {
                            <div><strong>Speed Limit:</strong> @CurrentSpeedLimit MPH</div>
                        }
                        <div><strong>Current Speed:</strong> @GetCurrentSpeed().ToString("F0") MPH</div>
                    }
                    <div><strong>Updates:</strong> @SequenceNumber</div>
                </div>
            }
        </div>
        
        <!-- Instructions -->
        <div class="mb-3">
            <div class="section-title">Instructions</div>
            <small class="text-muted">
                @if (SimulationMode == Mode.Initializing)
                {
                    <span>üìç Detecting your location...</span>
                }
                else if (SimulationMode == Mode.Stationary)
                {
                    <span>üëÜ Click anywhere on the map to set a destination</span>
                }
                else if (SimulationMode == Mode.Moving)
                {
                    <span>üöó Moving to destination. Click to change destination.</span>
                }
            </small>
        </div>
        
        <!-- Simulation Settings -->
        <div class="mb-3">
            <div class="section-title">Settings</div>
            
            <div class="mb-2">
                <label class="form-label">Update Interval (ms)</label>
                <input type="number" class="form-control form-control-sm" 
                       @bind="Settings.IntervalMs" 
                       min="100" max="10000" step="100" />
            </div>
            
            <div class="mb-2 form-check">
                <input type="checkbox" class="form-check-input" id="matchSpeedLimits"
                       @bind="MatchSpeedLimits" />
                <label class="form-check-label" for="matchSpeedLimits">Match Speed Limits</label>
            </div>
            
            <div class="mb-2">
                <label class="form-label">Speed (MPH) @(MatchSpeedLimits ? "(fallback)" : "")</label>
                <input type="number" class="form-control form-control-sm" 
                       @bind="Settings.SpeedMph" 
                       min="1" max="200" step="1"
                       disabled="@MatchSpeedLimits" />
            </div>
            
            <div class="mb-2">
                <label class="form-label">Device ID</label>
                <input type="text" class="form-control form-control-sm" 
                       @bind="Settings.DeviceId" />
            </div>
            
            <div class="mb-2">
                <label class="form-label">Webhook URL</label>
                <input type="text" class="form-control form-control-sm" 
                       @bind="Settings.WebhookUrl"
                       placeholder="Optional override" />
            </div>
            
            <div class="mb-2">
                <label class="form-label">Webhook Headers</label>
                <input type="text" class="form-control form-control-sm" 
                       @bind="Settings.WebhookHeaders"
                       placeholder="Header1:Value1;Header2:Value2" />
            </div>
        </div>
        
        <!-- Destination Info -->
        @if (EndPoint != null)
        {
            <div class="mb-3">
                <div class="section-title">Destination</div>
                <div class="coordinate-display" style="font-size: 0.8rem;">
                    <div><strong>Lat:</strong> @EndPoint.Latitude.ToString("F6")</div>
                    <div><strong>Lng:</strong> @EndPoint.Longitude.ToString("F6")</div>
                </div>
            </div>
        }
    </div>
</div>

@code {
    private MapboxInteropService? _mapService;
    private string? _accessToken;
    private double _circleRadiusMiles = 0.1;
    private CancellationTokenSource? _simulationCts;
    private Task? _simulationTask;
    
    // Current position state
    private Coordinate? CurrentPosition;
    private Coordinate? EndPoint;
    private RouteGeometry? CurrentRoute;
    
    // Simulation mode
    private Mode SimulationMode = Mode.Initializing;
    
    // Simulation settings
    private SimulationSettings Settings = new()
    {
        IntervalMs = 100,
        SpeedMph = 30.0,
        DeviceId = $"sim-{Guid.NewGuid().ToString()[..8]}",
        WebhookUrl = null
    };
    
    // Simulation tracking
    private double SimulationProgress = 0;
    private int SequenceNumber = 0;
    private DateTime RouteStartTime;
    private double DistanceTraveledMeters = 0;
    private DateTime LastTickTime;
    
    // Speed limit tracking
    private bool MatchSpeedLimits = false;
    private int? CurrentSpeedLimit = null;
    private int CurrentSegmentIndex = 0;
    
    private const double DefaultSpeedMph = 25.0;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeMapAsync();
        }
    }
    
    private async Task InitializeMapAsync()
    {
        try
        {
            // Get Mapbox configuration from server
            var config = await Http.GetFromJsonAsync<MapboxConfig>("api/configuration/mapbox");
            if (config != null)
            {
                _accessToken = config.AccessToken;
                _circleRadiusMiles = config.CircleRadiusMiles;
            }
            
            _mapService = new MapboxInteropService(JSRuntime);
            
            // Subscribe to events before initializing
            _mapService.OnMapClicked += OnMapClickedAsync;
            _mapService.OnInitialLocationReceived += OnInitialLocationAsync;
            
            await _mapService.InitializeAsync("map", _accessToken ?? "", null, 12, _circleRadiusMiles);
            
            // Enable click capture (this also sets the dotNetRef for callbacks)
            await _mapService.EnableClickCaptureAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
        }
    }
    
    private async Task OnInitialLocationAsync(double longitude, double latitude)
    {
        // Set initial position
        CurrentPosition = new Coordinate(latitude, longitude);
        SimulationMode = Mode.Stationary;
        
        // Start the continuous simulation loop
        StartSimulationLoop();
        
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task OnMapClickedAsync(double longitude, double latitude)
    {
        if (_mapService == null || CurrentPosition == null) return;
        
        try
        {
            // Get current marker position (in case we're moving)
            var markerPos = await _mapService.GetMarkerPositionAsync();
            if (markerPos != null)
            {
                CurrentPosition = new Coordinate(markerPos.Lat, markerPos.Lng);
            }
            
            // Set new destination
            EndPoint = new Coordinate(latitude, longitude);
            
            // Remove radius circle if shown
            await _mapService.RemoveRadiusCircleAsync();
            
            // Clear old route and waypoints
            await _mapService.ClearRouteAsync();
            await _mapService.ClearWaypointsAsync();
            
            // Place end marker
            await _mapService.SetWaypointAsync(longitude, latitude, "end");
            
            // Get directions from current position to destination
            var route = await _mapService.GetDirectionsAsync(CurrentPosition!, EndPoint);
            
            if (route != null)
            {
                CurrentRoute = route;
                await _mapService.DrawRouteAsync(route);
                
                // Start moving - reset all tracking variables
                SimulationMode = Mode.Moving;
                SimulationProgress = 0;
                DistanceTraveledMeters = 0;
                CurrentSegmentIndex = 0;
                CurrentSpeedLimit = null;
                RouteStartTime = DateTime.UtcNow;
                LastTickTime = DateTime.UtcNow;
                
                // Log speed limit availability
                Console.WriteLine($"Route has {route.SpeedLimits.Count} speed limit segments");
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling map click: {ex.Message}");
        }
    }
    
    private void StartSimulationLoop()
    {
        _simulationCts = new CancellationTokenSource();
        _simulationTask = RunSimulationLoopAsync(_simulationCts.Token);
    }
    
    private async Task RunSimulationLoopAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(Settings.IntervalMs));
            
            while (await timer.WaitForNextTickAsync(cancellationToken))
            {
                await SimulationTickAsync();
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when simulation is stopped
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Simulation loop error: {ex.Message}");
        }
    }
    
    private async Task SimulationTickAsync()
    {
        if (_mapService == null || CurrentPosition == null) return;
        
        try
        {
            if (SimulationMode == Mode.Moving && CurrentRoute != null)
            {
                // Calculate time since last tick
                var now = DateTime.UtcNow;
                var tickDeltaSeconds = (now - LastTickTime).TotalSeconds;
                LastTickTime = now;
                
                // Get current speed (based on speed limit mode)
                var currentSpeedMph = GetCurrentSpeed();
                var speedMetersPerSecond = currentSpeedMph * 1609.344 / 3600.0;
                
                // Accumulate distance traveled
                DistanceTraveledMeters += speedMetersPerSecond * tickDeltaSeconds;
                
                // Calculate progress as fraction of total route distance
                var routeDistanceMeters = CurrentRoute.DistanceMeters;
                SimulationProgress = Math.Min(1.0, DistanceTraveledMeters / routeDistanceMeters);
                
                // Interpolate position
                var interpolated = await _mapService.InterpolatePositionAsync(CurrentRoute, SimulationProgress);
                
                if (interpolated != null && interpolated.Position.Length >= 2)
                {
                    var lng = interpolated.Position[0];
                    var lat = interpolated.Position[1];
                    CurrentPosition = new Coordinate(lat, lng);
                    
                    // Update speed limit from current segment
                    CurrentSegmentIndex = interpolated.SegmentIndex;
                    if (MatchSpeedLimits && CurrentRoute.SpeedLimits.Count > CurrentSegmentIndex)
                    {
                        CurrentSpeedLimit = CurrentRoute.SpeedLimits[CurrentSegmentIndex];
                    }
                    
                    // Animate marker
                    await _mapService.AnimateMarkerAsync(lng, lat, interpolated.Bearing, Settings.IntervalMs);
                    
                    // Send GPS data with actual current speed
                    _ = SendGpsDataAsync(lat, lng, interpolated.Bearing, currentSpeedMph);
                    SequenceNumber++;
                }
                
                // Check if we've reached the destination
                if (SimulationProgress >= 1.0)
                {
                    await OnReachedDestinationAsync();
                }
            }
            else if (SimulationMode == Mode.Stationary)
            {
                // When stationary, just keep sending current position
                _ = SendGpsDataAsync(CurrentPosition.Latitude, CurrentPosition.Longitude, 0, 0);
                SequenceNumber++;
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Simulation tick error: {ex.Message}");
        }
    }
    
    private async Task OnReachedDestinationAsync()
    {
        if (_mapService == null || CurrentPosition == null) return;
        
        Console.WriteLine($"Reached destination at: {CurrentPosition.Latitude}, {CurrentPosition.Longitude}");
        
        // Transition to stationary mode
        SimulationMode = Mode.Stationary;
        
        // Clear route and end marker
        await _mapService.ClearRouteAsync();
        await _mapService.ClearWaypointsAsync();
        
        // Small delay to ensure Mapbox has finished removing layers
        await Task.Delay(100);
        
        // Draw radius circle at current position using configured radius
        Console.WriteLine($"Drawing radius circle at: {CurrentPosition.Longitude}, {CurrentPosition.Latitude}, radius: {_circleRadiusMiles} miles");
        await _mapService.DrawRadiusCircleAsync(CurrentPosition.Longitude, CurrentPosition.Latitude, _circleRadiusMiles);
        
        // Clear route data
        CurrentRoute = null;
        EndPoint = null;
        SimulationProgress = 0;
    }
    
    private async Task SendGpsDataAsync(double latitude, double longitude, double bearing, double speedMph = 0)
    {
        try
        {
            // Convert MPH to m/s
            var speedMetersPerSecond = speedMph * 1609.344 / 3600.0;
            
            var payload = new GpsPayload
            {
                DeviceId = Settings.DeviceId,
                Latitude = latitude,
                Longitude = longitude,
                Altitude = 0,
                Speed = speedMetersPerSecond,
                Bearing = bearing,
                Accuracy = 5.0,
                Timestamp = DateTime.UtcNow,
                SequenceNumber = SequenceNumber
            };
            
            var queryParams = new List<string>();
            
            if (!string.IsNullOrEmpty(Settings.WebhookUrl))
            {
                queryParams.Add($"webhookUrl={Uri.EscapeDataString(Settings.WebhookUrl)}");
            }
            
            if (!string.IsNullOrEmpty(Settings.WebhookHeaders))
            {
                queryParams.Add($"webhookHeaders={Uri.EscapeDataString(Settings.WebhookHeaders)}");
            }
            
            var url = queryParams.Count > 0 
                ? $"api/webhook/broadcast?{string.Join("&", queryParams)}" 
                : "api/webhook/broadcast";
            
            await Http.PostAsJsonAsync(url, payload);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending GPS data: {ex.Message}");
        }
    }
    
    private string GetStatusClass() => SimulationMode switch
    {
        Mode.Initializing => "status-idle",
        Mode.Stationary => "status-paused",
        Mode.Moving => "status-running",
        _ => "status-idle"
    };
    
    private string GetStatusText() => SimulationMode switch
    {
        Mode.Initializing => "Initializing...",
        Mode.Stationary => "Stationary (sending updates)",
        Mode.Moving => "Moving to destination",
        _ => "Unknown"
    };
    
    /// <summary>
    /// Gets the current speed based on settings and speed limit mode
    /// </summary>
    private double GetCurrentSpeed()
    {
        if (!MatchSpeedLimits)
        {
            // When Match Speed Limits is OFF, use the default 25 MPH
            return DefaultSpeedMph;
        }
        
        // When Match Speed Limits is ON:
        // - Use the current road's speed limit if available
        // - Otherwise, keep the current/previous speed (fallback)
        if (CurrentSpeedLimit.HasValue)
        {
            return CurrentSpeedLimit.Value;
        }
        
        // Fallback to configured speed when speed limit is unknown
        return Settings.SpeedMph;
    }
    
    public async ValueTask DisposeAsync()
    {
        _simulationCts?.Cancel();
        _simulationCts?.Dispose();
        
        if (_simulationTask != null)
        {
            try
            {
                await _simulationTask;
            }
            catch
            {
                // Ignore
            }
        }
        
        if (_mapService != null)
        {
            _mapService.OnMapClicked -= OnMapClickedAsync;
            _mapService.OnInitialLocationReceived -= OnInitialLocationAsync;
            await _mapService.DisposeAsync();
        }
    }
    
    private record MapboxConfig(string AccessToken, double CircleRadiusMiles = 0.1);
    
    private enum Mode
    {
        Initializing,
        Stationary,
        Moving
    }
}
